<script type="text/javascript">
    // --- 1. Setup Vis.js ---
    // Start with some default data
    var nodes = new vis.DataSet([
        {id: 1, label: 'A'},
        {id: 2, label: 'B'},
        {id: 3, label: 'C'},
        {id: 4, label: 'D'},
        {id: 5, label: 'E'}
    ]);

    var edges = new vis.DataSet([
        {from: 1, to: 2},
        {from: 1, to: 3},
        {from: 2, to: 4},
        {from: 2, to: 5}
    ]);

    var container = document.getElementById('mynetwork');
    var data = { nodes: nodes, edges: edges };
    
    var options = {
        nodes: {
            shape: 'dot',
            size: 20,
            font: { size: 16, face: 'Montserrat', color: '#1a365d' },
            borderWidth: 2,
            color: { 
                border: '#1a365d', 
                background: '#ffffff', 
                highlight: { border: '#e67e22', background: '#fffaf0' } 
            }
        },
        edges: {
            width: 2,
            color: { color: '#cbd5e0', highlight: '#e67e22' },
            smooth: { type: 'continuous' }
        },
        physics: {
            stabilization: false,
            barnesHut: { gravitationalConstant: -2000, springConstant: 0.04 }
        },
        interaction: { 
            navigationButtons: true, 
            keyboard: true 
        },
        // --- THE FIX IS HERE ---
        manipulation: {
            enabled: true,
            initiallyActive: true,
            addNode: function(nodeData, callback) {
                // When user clicks the canvas, this function runs.
                // We ask for a label.
                var label = prompt("Enter Node Name:", "Node " + (nodes.length + 1));
                
                if (label !== null) {
                    nodeData.label = label;
                    callback(nodeData); // This actually adds the node
                } else {
                    callback(null); // User cancelled
                }
            },
            addEdge: function(edgeData, callback) {
                // When user drags a line between nodes
                if (edgeData.from === edgeData.to) {
                    var r = confirm("Do you want to connect the node to itself?");
                    if (r === true) {
                        callback(edgeData);
                    }
                } else {
                    callback(edgeData);
                }
            },
            editEdge: false,
            deleteNode: true,
            deleteEdge: true
        }
    };

    var network = new vis.Network(container, data, options);

    // --- 2. Helper Functions (Presets) ---
    
    function clearGraph() {
        nodes.clear();
        edges.clear();
    }

    function loadPreset(type) {
        clearGraph();
        if(type === 'k5') {
            // Create K5
            let newNodes = [];
            let newEdges = [];
            for(let i=1; i<=5; i++) newNodes.push({id: i, label: String(i)});
            for(let i=1; i<=5; i++) {
                for(let j=i+1; j<=5; j++) {
                    newEdges.push({from: i, to: j});
                }
            }
            nodes.add(newNodes);
            edges.add(newEdges);
        }
        else if(type === 'bipartite') {
            // K3,3
            nodes.add([
                {id: 1, label: 'U1', color: {background:'#fed7d7'}}, {id: 2, label: 'U2', color: {background:'#fed7d7'}}, {id: 3, label: 'U3', color: {background:'#fed7d7'}},
                {id: 4, label: 'V1', color: {background:'#bee3f8'}}, {id: 5, label: 'V2', color: {background:'#bee3f8'}}, {id: 6, label: 'V3', color: {background:'#bee3f8'}}
            ]);
            edges.add([
                {from:1,to:4}, {from:1,to:5}, {from:1,to:6},
                {from:2,to:4}, {from:2,to:5}, {from:2,to:6},
                {from:3,to:4}, {from:3,to:5}, {from:3,to:6}
            ]);
        }
        else if (type === 'petersen') {
            // Simple outer ring + inner star approximation
            for(let i=0; i<5; i++) nodes.add({id: i, label: String(i)}); // Outer
            for(let i=5; i<10; i++) nodes.add({id: i, label: String(i)}); // Inner
            
            // Outer cycle
            edges.add([{from:0,to:1}, {from:1,to:2}, {from:2,to:3}, {from:3,to:4}, {from:4,to:0}]);
            // Inner star
            edges.add([{from:5,to:7}, {from:7,to:9}, {from:9,to:6}, {from:6,to:8}, {from:8,to:5}]);
            // Spokes
            for(let i=0; i<5; i++) edges.add({from: i, to: i+5});
        }
    }

    function resetColor() {
        var allNodes = nodes.get();
        allNodes.forEach(n => {
            nodes.update({id: n.id, color: {background: '#ffffff', border: '#1a365d'}});
        });
    }

    // --- 3. Example Algorithm: Random BFS ---
    function runBFS() {
        // A simple visual simulation of "visiting" nodes
        let allIds = nodes.getIds();
        if(allIds.length === 0) return;
        
        resetColor();
        
        let i = 0;
        let interval = setInterval(() => {
            if (i >= allIds.length) {
                clearInterval(interval);
                return;
            }
            // Randomly pick a node to "visit" just for demo
            let id = allIds[i];
            nodes.update({id: id, color: {background: '#e67e22', border: '#e67e22'}});
            i++;
        }, 500);
    }
</script>
